Summary
---
- `make -nB` 观察 make 指令
- 反汇编生成的 sqrt_ispc.o, 发现很多操作的确都向量化了, 见 sqrt_ispc.s
1. ispc 加速5x, ispc with 64 tasks 加速24x.
2. `values[i] = 1.f;` 使线性的算法最快, 因为1次即猜中. 此时加速效果非常不明显, 因为没有需要向量化的地方. 而对于多任务的来说, 因为完成的太快了, 64个任务只启动了3个.
3. `values[i] = 2.999f;` 使线性的算法最慢, 因为猜不中, 所以有大量的计算, 而这些计算都是可以被向量化的.
4. - `__mm256d` 指4个double `__mm256`指8个float 
   - AVX2 包含 AVX 的指令
   - 对于绝对值, 我们使用两次判断来回避
   - 在判断的时候想了很久也没想到更好的办法, 只能提取出来一个一个判断, extract 是 sequential的
   - 因为不论怎么比较都只能是 256bit 级别的, 无法产生一个 bool 来判断
   - 经过检查, C++的堆上内存对齐比栈上内存对齐麻烦许多, 要想对齐在C++17之前只能重写 new
   - 所以使用 `_mm256_loadu_ps` 而非 `_mm256_load_ps`
